# Chapter 9. Sequential Containers

## Exercise 9.1:

> 对于下面的程序任务，`vector`、`deque`和`list`哪种容器最为适合？解释你的选择的理由。如果没有哪一种容器优于其他容器，也请解释理由。
* (a) 读取固定数量的单词，将它们按字典序插入到容器中。我们将在下一章中看到，关联容器更适合这个问题。
* (b) 读取未知数量的单词，总是将单词插入到末尾。删除操作在头部进行。
* (c) 从一个文件读取未知数量的整数。将这些数排序，然后将它们打印到标准输出。

解：
* (a) 分析：
* “按字典序插入到容器中” `-->` 进行插入排序操作 `-->` 需要在容器内部频繁进行插入操作。
* 比较：
* `vector`在尾部之外的位置插入和删除元素很慢
* `deque` 在头尾之外的位置插入和删除元素很慢
* `list` 在任何位置插入和删除都很快，故选择`list`
* 特例：
* 如果不是必须边读取单词边插入单词到容器中，还可以使用`vector`，将读取的单词依次追加到尾部，读取完毕后，再使用排序算法将单词重新排序为字典序

* (b) 分析：
*  `deque` 和`list` 都可以达到很好的性能。如果还需要频繁进行随机访问，则`deque` 更好。

* (c) 分析：
*  由于整数占用空间很小，且快速的排序算法需频繁随机访问元素，将`list`排除在外。由于无需在头部进行插入和删除操作，因此使用`vector`即可，无需使用`deque`

## 练习9.2

> 定义一个`list`对象，其元素类型是`int`的`deque`。

解：

```cpp
std::list<std::deque<int>> l;
```

## 练习9.3

> 构成迭代器范围的迭代器有何限制？

解：

两个迭代器 `begin` 和 `end`需满足以下条件：
* 它们指向同一个容器中的元素，或者是容器最后一个元素之后的位置。
* 我们可以通过反复递增`begin`来到达`end`。换句话说，`end` 不在`begin`之前。

## 练习9.6
>下面的程序有何错误？你应该如何修改它？

```cpp
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(),
					iter2 = lst1.end();
while (iter1 < iter2) 
    /* ... */
```

* 出题思路
>理解迭代器在不同类型容器间的差别。更深层次的，理解数据结构的实现如何导致迭代器的差别

* 解答
> 1. 与`vector` 和 `deque`不同，`list` 的迭代器不支持`<`运算，只支持递增、递减、`==`和`!=`运算。
> 2. 原因在于这几种数据结构实现上的不同，`vector` 和 `deque`将元素在内存中连续保存，而`list`则是将元素以链表的形式存储。
> 3. 故`vector` 和 `deque`可以通过迭代器的大小比较（类似指针的大小比较）来体现元素的前后关系。
> 4. 但在`list`中，两个指针的大小关系与它们指向的元素的前后关系并不一定吻合，实现`<`运算将会非常困难和低效。

* 修改为
```cpp
while (iter1 != iter2)
```

## 练习9.7

> 为了索引`int`的`vector`中的元素，应该使用什么类型？

* 解答
> 使用迭代器类型`vector<int>::iterator`来索引`int`的`vector`中的元素


## 练习9.8

> 为了读取`string`的`list`中的元素，应该使用什么类型？如果写入`list`，又应该使用什么类型？

* 出题思路

> 理解容器的类型成员

* 解答

> 为了读取`string`的`list`中的元素，应使用`list<string>::value_type`,因为`value_type`是元素类型
> 
> 为了写入数据，需要引用类型（非常量），因此使用`list<string>::reference`。

## 练习9.9

> `begin`和`cbegin`两个函数有什么不同？

* 出题思路

> `begin`和`end`都有多个版本，分别返回普通、反向和`const`迭代器。旨在理解不同版本间的差异。

* 解答
  
> `cbegin`是`c++`新标准引入的，用来与`auto`结合使用。它返回指向容器第一个元素的`const`迭代器，可以用来只读地访问容器元素，但不能对容器元素进行修改。因此，当不需要写访问时，应该使用`cbegin`。
> 
> `begin` 则是被重载过的，有两个版本：其中一个是`const`成员函数，也返回`const`迭代器；另一个则返回普通迭代器，可以对容器元素进行修改。


## 练习9.10

> 下面4个对象分别是什么类型？
```cpp
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
```

* 出题思路

> 通过实例来理清`begin`不同版本的差异和不同类型迭代器的差异。

* 解答
> `v1`是`int`的`vector`类型，我们可以修改`v1`的内容，包括添加、删除和修改等操作。
> 
> `v2`是`int`的`const vector`类型，我们不能修改`v1`的内容。
> 
> `begin`和`auto`配合使用时，迭代器的类型由调用对象的类型来决定，因此`c1`是普通迭代器，可对容器元素进行读写访问，而`it2`是`const`迭代器，不能对容器元素进行访问。
> 
> `cbegin`则不管调用对象是什么类型，始终返回`const`迭代器，因此`it3`和`it4`都是`const`迭代器。
> 

## 练习9.11

> 对6种创建和初始化`vector`对象的方法，每一种都给出一个实例。解释每个`vector`包含什么值。

* 解答

```cpp
vector<int> vec;    // 0
vector<int> vec(10);    // 10个0
vector<int> vec(10, 1);  // 10个1
vector<int> vec{ 1, 2, 3, 4, 5 }; // 1, 2, 3, 4, 5
vector<int> vec(other_vec); // 拷贝 other_vec 的元素
vector<int> vec(other_vec.begin(), other_vec.end()); // 拷贝 other_vec 的元素
```


## 练习9.12

> 对于接受一个容器创建其拷贝的构造函数，和接受两个迭代器创建拷贝的构造函数，解释它们的不同。

* 出题思路

> 继续熟悉不同的初始化方式

* 解答
> 当我们确实需要一个容器的完整拷贝时，这种方式更方便。
> 当我们只需要容器的一部分元素时，选择第二种方式。


## 练习9.13

> 如何从一个`list<int>`初始化一个`vector<double>`？从一个`vector<int>`又该如何创建？编写代码验证你的答案。

* 出题思路
> 更深入地理解容器拷贝初始化和范围初始化两种方式的差异。

* 解答
> 由于`list<int>` 与 `vector<double>` 是不同的容器类型，因此无法采用容器拷贝初始化方式。但前者的元素类型是 `int` ，与 `double` 是相容的。故可以采用范围初始化方式来构造一个 `vector<double>`，令它的元素值与 `list<int>` 完全相同。对 `vector<int>` 同理。
> 
> 小结：容器类型不同，不能使用拷贝初始化；元素类型相容，因此可采用范围初始化。

```cpp
list<int> ilst(5, 4);
vector<int> ivc(5, 5);

vector<double> dvc(ilst.begin(), ilst.end());
vector<double> dvc2(ivc.begin(), ivc.end());
```

## 练习9.23

> 在本节第一个程序中，若`c.size()` 为1，则`val`、`val2`、`val3`和`val4`的值会是什么？

解：

都会是同一个值（容器中仅有的那个）。

## 练习9.24

> 编写程序，分别使用`at`、下标运算符、`front` 和 `begin` 提取一个`vector`中的第一个元素。在一个空`vector`上测试你的程序。

解：

```cpp
#include <iostream>
#include <vector>

int main()
{
    std::vector<int> v;
    std::cout << v.at(0);       // terminating with uncaught exception of type std::out_of_range
    std::cout << v[0];          // Segmentation fault: 11
    std::cout << v.front();     // Segmentation fault: 11
    std::cout << *v.begin();    // Segmentation fault: 11
    return 0;
}
```

## 练习9.25

> 对于第312页中删除一个范围内的元素的程序，如果 `elem1` 与 `elem2` 相等会发生什么？如果 `elem2` 是尾后迭代器，或者 `elem1` 和 `elem2` 皆为尾后迭代器，又会发生什么？

* 出题思路
> 理解范围删除操作的两个迭代器参数如何决定删除操作的结果。

* 解答
> 如果两个迭代器`elem1` 和 `elem2`相等，则什么也不会发生，容器保持不变。哪怕两个迭代器是指向尾后位置（`end()+1`）也是如此，程序也不会出错。
> 如果`elem2` 是尾后迭代器，那么删除从 `elem1` 到最后的元素。

## 练习9.29

> 假定`vec`包含25个元素，那么`vec.resize(100)`会做什么？如果接下来调用`vec.resize(10)`会做什么？

解：

* 将75个值为0的元素添加到`vec`的末尾
* 从`vec`的末尾删除90个元素

## 练习9.30

> 接受单个参数的`resize`版本对元素类型有什么限制（如果有的话）？

* 出题思路


## 练习9.32

> 在第316页的程序中，向下面语句这样调用`insert`是否合法？如果不合法，为什么？

```cpp
iter = vi.insert(iter, *iter++);
```

解：

不合法。因为参数的求值顺序是未指定的。

## 练习9.33

> 在本节最后一个例子中，如果不将`insert`的结果赋予`begin`，将会发生什么？编写程序，去掉此赋值语句，验证你的答案。

解：

`begin`将会失效。