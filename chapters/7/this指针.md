# 一些概念
<!-- TOC -->

- [一些概念](#一些概念)
    - [问题？](#问题)
    - [`this`指针](#this指针)
  - [静态成员](#静态成员)
    - [静态成员](#静态成员-1)
    - [静态成员函数](#静态成员函数)
  - [友元](#友元)

<!-- /TOC -->

在建立对象时，系统会为每一个对象分配独立的存储空间,也就是给每个对象中的数据成员都分配有自己独立的存储空间。如果对同一个类定义`n`个对象，则有`n`组同样大小的空间以存放对象中的数据成员。但对于成员函数来说，对象中的数据成员。一个函数的代码段在内存中只有一份。也就是说，函数的代码段在内存中只有一份。也就是说，同一个类中的不同对象在调用自己的成员函数时，一个类中的不同对象在调用自己的成员函数时，其实它们调用的是同一段函数代码。那么，其实它们调用的是同一段函数代码。

### 问题？
当一个对象调用自己的成员函数时，如何保证成员函数中对数据成员的处理是针对自己的数据成员而不是其他对象的数据成员呢？
 
### `this`指针
假设用一个类定义`10`个对象：
编译系统并不是分别为`10`个对象的数据成员和成员函数分配存储单元。而是仅为每个对象的数据成员分配存储单元，`10`个对象的成员函数对应的是同一个函数代码段。不论成员函数在类内定义还是在类外定义，成员函数都用以上方式存储。其实，在每一个成员函数中都包含一个特殊的指针，这个指针的名字是固定的，称为`this`， 它的值是当前被调用的成员函数所在的对象的起始地址。在调用成员函数时，系统隐式地将对象的起始地址传递给成员函数，使`this`指针得到当前对象的地址。于是在成员函数中对数据成员的引用，就按照`this`的指向找到对象的数据成员，实现对数据成员的操作。也就是说，成员函数中数据成员名的前面隐含有`this->`的指向。 
this指针 
```cpp
int Box∷tiji( )  {return (h*w*l); }
int Box∷tiji( )  {return (this->h*this->w*this->l); }
```
假设`a`是`box`类对象，当执行`a.tiji()`时，`this=&a`当执行时`int Box∷tiji( ) {return (a.h*a.w*a.l); }`。

## 静态成员 
用于类的某成员，在`c++`中，可以将关键字`static`用于类的某成员，这样该成员就成为静态成员了。静态成员包括：静态数据成员、静态成员函数。静态数据成员被类的所有对象共享。

```cpp
class Box {
   public:
      int tiji();
   private:
      static int h;
      int w;
      int l;
};
```

`h`为静态数据成员，它为各对象所共有。即使有多个`box`对象，`h`在内存中只占一份空间（而不是每个对象都分配`h`空间）。`h`的值对所有对象都是一样的，若改变`h`的值，
则各对象`h`的值都同时改变了。

```cpp
#include <iostream>
using namespace std;
class Box {
   public:
      Box(int,int);
      int tiji( );
      static int h;
      int w;
      int l;
};
Box∷Box(int b,int c) 
{
   w=b;
   l=c;
}
int Box∷tiji( )
{
   return(h*w*l);
}
int Box∷h=10;
int main( )
{
   Box a(15,20),b(20,30);
   cout<<a.h<<endl;
   cout<<b.h<<endl;
   cout<<Box∷h<<endl;
   cout<<a.tiji( )<<endl;
   return 0;
}
```
`(1)`在一个类中可以有一个或多个静态数据成员。静态数据成员不属于某一个对象，在为对象所分配的空间中不包括静态数据成员所占的空间。静态数据成员是在所有对象之外单独开辟空间。只要在类中定义了静态数据成员，即使不定义对象，也为静态数据成员分配空间。 

`(2)`静态数据成员可以初始化，但只能在类体外进行初始化。形式为：`数据类型类名∷静态数据成员名=初值`； 

`(3)`静态数据成员既可以通过对象名引用，也可以通过类名来引用。 

`(4)`静态数据成员是在程序编译时被分配空间的，到程序结束时才释放空间。 

```cpp
#include <iostream>
using namespace std;
class Objcount {
   private: 
     static int count; 该程序可用来统计Objcount对象的个数。
   public:
     Objcount() 若将static去掉，就不能完成该功能。 
    {
      count++;
    }
    int get()
    {
       return count;
    }
};

int Objcount::count=0;
int main() {
     Objcount a1,a2,a3;
     cout<<”对象的数量是:”<<a1.get();
     cout<<”对象的数量是:”<<a2.get();
     cout<<”对象的数量是:”<<Objcount.get(); 
}
```

### 静态成员
静态数据成员为在一个类范围的数据共享提供了技术支持，而不必使用全局变量。静态数据成员的主要用途是定义类的各个对象所公用的数据。

### 静态成员函数
成员函数也可以定义为静态的。与静态数据成员不同，静态成员函数的作用不是为了对象之间的沟通，而是为了能处理静态数据成员。静态成员函数可以访问静态数据成员，而不能访问非静态成员。 
 
## 友元
友元通俗地说，就是一个类主动声明本类以外的某个函数是它的朋友，进而给它们提供访问本类成员的特许。友元包括友元函数和友元类两种：

`(1)` 如果在本类中用`friend`对本类以外的某个函数进行了声明，则该函数就成为本类的友元函数。这样，它虽然不是本类的成员函数，但它可以访问本类的所有成员，无论是公有成员还是私有成员。声明为友元的函数可以是不属于任何类的普通函数，也可以是其它类的成员函数。 

`(2)`如果在本类中（例如`A`类 对另一个类例如`B`类）进行了声明，则`B`类就是类的友元类。这时，类就是`A`类的友元类。类`B`中的所有函数就都自动成为类`A`的友元函数。 

